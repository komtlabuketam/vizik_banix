{"id": 25, "contentVariable": "const mediump float zoom = 0.92;\nconst mediump float corner_radius = 0.12;\nconst mediump vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst mediump vec2 c00 = vec2(0.0, 0.0);\nconst mediump vec2 c01 = vec2(0.0, 1.0);\nconst mediump vec2 c11 = vec2(1.0, 1.0);\nconst mediump vec2 c10 = vec2(1.0, 0.0);", "contentFunction": "bool in_corner(mediump vec2 p, mediump vec2 corner, mediump vec2 radius) {\n    mediump vec2 axis = (c11 - corner) - corner;\n    p = p - (corner + axis * radius);\n    p *= axis / radius;\n    return (p.x > 0.0 && p.y > -1.0) || (p.y > 0.0 && p.x > -1.0) || dot(p, p) < 1.0;\n}\n\nbool test_rounded_mask(mediump vec2 p, mediump vec2 corner_size) {\n    return\n    in_corner(p, c00, corner_size) &&\n    in_corner(p, c01, corner_size) &&\n    in_corner(p, c10, corner_size) &&\n    in_corner(p, c11, corner_size);\n}\n\nmediump vec4 screen(mediump vec4 a, mediump vec4 b) {\n    return 1.0 - (1.0 - a) * (1.0 -b);\n}\n\nmediump vec4 unscreen(mediump vec4 c) {\n    return 1.0 - sqrt(1.0 - c);\n}\n\nmediump vec4 sample_with_corners_from(mediump vec2 p, mediump vec2 corner_size) {\n    p = (p - 0.5) / zoom + 0.5;\n    if (!test_rounded_mask(p, corner_size)) {\n        return black;\n    }\n    return unscreen(texture2D(iChannel1,p));\n}\n\nmediump vec4 sample_with_corners_to(mediump vec2 p, mediump vec2 corner_size) {\n    p = (p - 0.5) / zoom + 0.5;\n    if (!test_rounded_mask(p, corner_size)) {\n        return black;\n    }\n    return unscreen(texture2D(iChannel3,p));\n}\n\nmediump vec4 simple_sample_with_corners_from(mediump vec2 p, mediump vec2 corner_size, mediump float zoom_amt) {\n    p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;\n    if (!test_rounded_mask(p, corner_size)) {\n        return black;\n    }\n    return texture2D(iChannel1,p);\n}\n\nmediump vec4 simple_sample_with_corners_to(mediump vec2 p, mediump vec2 corner_size, mediump float zoom_amt) {\n    p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;\n    if (!test_rounded_mask(p, corner_size)) {\n        return black;\n    }\n    return texture2D(iChannel3,p);\n}\n\nmediump mat3 rotate2d(mediump float angle, mediump float ratio) {\n    mediump float s = sin(angle);\n    mediump float c = cos(angle);\n    return mat3(\n    c, s ,0.0,\n    -s, c, 0.0,\n    0.0, 0.0, 1.0);\n}\n\nmediump mat3 translate2d(mediump float x, mediump float y) {\n    return mat3(\n    1.0, 0.0, 0,\n    0.0, 1.0, 0,\n    -x, -y, 1.0);\n}\n\nmediump mat3 scale2d(mediump float x, mediump float y) {\n    return mat3(\n    x, 0.0, 0,\n    0.0, y, 0,\n    0, 0, 1.0);\n}\n\nmediump vec4 get_cross_rotated(mediump vec3 p3, mediump float angle, mediump vec2 corner_size, mediump float ratio) {\n    angle = angle * angle; // easing\n    angle /= 2.4; // works out to be a good number of radians\n\n    mediump mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);\n    mediump mat3 unscale_and_uncenter = scale2d(1.0, 1.0/ratio) * translate2d(0.5,0.5);\n    mediump mat3 slide_left = translate2d(-2.0,0.0);\n    mediump mat3 slide_right = translate2d(2.0,0.0);\n    mediump mat3 rotate = rotate2d(angle, ratio);\n\n    mediump mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;\n    mediump mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;\n\n    mediump vec4 a = sample_with_corners_from((op_a * p3).xy, corner_size);\n    mediump vec4 b = sample_with_corners_from((op_b * p3).xy, corner_size);\n\n    return screen(a, b);\n}\n\nmediump vec4 get_cross_masked(mediump vec3 p3, mediump float angle, mediump vec2 corner_size, mediump float ratio) {\n    angle = 1.0 - angle;\n    angle = angle * angle; // easing\n    angle /= 2.4;\n\n    mediump vec4 img;\n\n    mediump mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);\n    mediump mat3 unscale_and_uncenter = scale2d(1.0 / zoom, 1.0 / (zoom * ratio)) * translate2d(0.5,0.5);\n    mediump mat3 slide_left = translate2d(-2.0,0.0);\n    mediump mat3 slide_right = translate2d(2.0,0.0);\n    mediump mat3 rotate = rotate2d(angle, ratio);\n\n    mediump mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;\n    mediump mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;\n\n    bool mask_a = test_rounded_mask((op_a * p3).xy, corner_size);\n    bool mask_b = test_rounded_mask((op_b * p3).xy, corner_size);\n\n    if (mask_a || mask_b) {\n        img = sample_with_corners_to(p3.xy, corner_size);\n        return screen(mask_a ? img : black, mask_b ? img : black);\n    } else {\n        return black;\n    }\n}", "contentTransition": "mediump float ratio = iResolution.x/ iResolution.y;\n        mediump float progress = translatePercent;\n        mediump float a;\n        mediump vec2 p=uv.xy/vec2(1.0).xy;\n        mediump vec3 p3 = vec3(p.xy, 1.0);\n        mediump vec2 corner_size = vec2(corner_radius / ratio, corner_radius);\n\n        if (progress <= 0.0) {\n            background = texture2D(iChannel1,p).rgb;\n        } else if (progress < 0.1) {\n            a = progress / 0.1;\n            background =  simple_sample_with_corners_from(p, corner_size * a, a).rgb;\n        } else if (progress < 0.48) {\n            a = (progress - 0.1)/0.38;\n            background= get_cross_rotated(p3, a, corner_size, ratio).rgb;\n        } else if (progress < 0.9) {\n            background = get_cross_masked(p3, (progress - 0.52)/0.38, corner_size, ratio).rgb;\n        } else if (progress < 1.0) {\n            a = (1.0 - progress) / 0.1;\n            background = simple_sample_with_corners_to(p, corner_size * a, a).rgb;\n        } else {\n            background = texture2D(iChannel3,p).rgb;\n        }"}
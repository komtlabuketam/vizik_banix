{
  "audioUrl": "Music/Audio/DrumBass/piano-high-notes-melody-with-dance-beat-180-bpm-10206.mp3",
  "audioFileName": "piano-high-notes-melody-with-dance-beat-180-bpm-10206.mp3",
  "thumbUrl": "",
  "thumbFileName": "",
  "visualizerSource": {
    "contentVariable": "",
    "contentFunction": "highp float weirdSin(highp float x, highp float amplitude, highp float halfWidth) {\n    highp float timeVar;\n    if(fract(iTime)<0.5){\n        timeVar = iTime;\n    } else {\n        timeVar = 1.0-iTime;\n    }\n    highp float f1 = sin(x*220.0);\n    highp float spdMult = 2.0;\n    highp float wavNoise = 200.0+(spdMult*fract(timeVar));\n    highp float f2 = sin(x*wavNoise);\n\n\n    highp float amp = amplitude;\n    //where halfWidth lives\n    highp float g1 = pow((x-halfWidth),2.0);\n    highp float g2 = (-(g1)*(amp*4.0))+amp;\n\n    highp float h = (((f1*f2)/2.0)*g2)+0.5;\n    return h;\n}",
    "contentVisualizer": "uv = gl_FragCoord.xy/iResolution.xy;\n\n    highp float baseAmp = .1;\n    highp float funkyFactor = 1.65;\n    highp float funkyTime = (texture2D(iChannel0, vec2(uv.x, 0.)).x*funkyFactor)-baseAmp;\n    if(funkyTime < 0.){\n        funkyTime *= -1.;\n    }\n    highp vec3 rgbWav;\n    if (uv.y > weirdSin(uv.x, funkyTime,0.55)){\n        if (uv.y < 0.5){\n            rgbWav = vec3(0.55);\n        } else {\n            rgbWav = vec3(0.0);\n        }\n    } else {\n        if (uv.y < 0.5){\n            rgbWav = vec3(0.0);\n        } else {\n            rgbWav = vec3(0.55);\n        }\n    }\n    highp vec3 rgbWav2;\n    if (uv.y > weirdSin(uv.x, funkyTime, 0.45)){\n        if (uv.y < 0.5){\n            rgbWav2 = vec3(0.85);\n        } else {\n            rgbWav2 = vec3(0.0);\n        }\n    } else {\n        if (uv.y < 0.5){\n            rgbWav2 = vec3(0.0);\n        } else {\n            rgbWav2 = vec3(0.85);\n        }\n    }\n    highp vec3 rgbWav3;\n    if (uv.y > weirdSin(uv.x, funkyTime, 0.5)){\n        if (uv.y < 0.5){\n            rgbWav3 = vec3(1.);\n        } else {\n            rgbWav3 = vec3(0.0);\n        }\n    } else {\n        if (uv.y < 0.5){\n            rgbWav3 = vec3(0.0);\n        } else {\n            rgbWav3 = vec3(1.);\n        }\n    }\n\n    highp vec3 lines = vec3(sin(uv.x*iResolution.x*1.2));\n    highp vec3 wavLines = rgbWav * lines;\n    highp vec3 wavLines2 = rgbWav2 * lines;\n    highp vec3 wavLines3 = rgbWav2 * lines;\n\n\n    // Output to screen\n    visualizer = vec3(wavLines.x, wavLines2.x, wavLines3.x);"
  },
  "particleSource": {
    "contentVariable": "#define PASS_COUNT 1\nhighp float fBrightness=2.5;\nhighp float fSteps=222.;\nhighp float fParticleSize=.015;\nhighp float fParticleLength=.5/60.;\nhighp float fMinDist=.8;\nhighp float fMaxDist=5.;\nhighp float fRepeatMin=1.;\nhighp float fRepeatMax=2.;\nhighp float fDepthFade=1.2;\nconst highp float sharpness=2.;",
    "contentFunction": "highp float Random(highp float x){\n    return fract(sin(x*123.456)*23.4567+sin(x*345.678)*45.6789+sin(x*456.789)*56.789);\n}\n\nhighp vec3 GetParticleColour(const in highp vec3 vParticlePos,const in highp float fParticleSize,const in highp vec3 vRayDir){\n    highp vec2 vNormDir=normalize(vRayDir.xy);\n    highp float d1=dot(vParticlePos.xy,vNormDir.xy)/length(vRayDir.xy);\n    highp vec3 vClosest2d=vRayDir*d1;\n\n    highp vec3 vClampedPos=vParticlePos;\n\n    vClampedPos.z=clamp(vClosest2d.z,vParticlePos.z-fParticleLength,vParticlePos.z+fParticleLength);\n\n    highp float d=dot(vClampedPos,vRayDir);\n\n    highp vec3 vClosestPos=vRayDir*d;\n\n    highp vec3 vDeltaPos=vClampedPos-vClosestPos;\n\n    highp float fClosestDist=length(vDeltaPos)/fParticleSize;\n\n    highp float fShade=clamp(1.-fClosestDist,0.,1.);\n\n    fShade=fShade*exp2(-d*fDepthFade)*fBrightness;\n\n    return vec3(fShade);\n}\n\nhighp vec3 GetParticlePos(const in highp vec3 vRayDir,const in highp float fZPos,const in highp float fSeed){\n    highp float fAngle=atan(vRayDir.x,vRayDir.y);\n    highp float fAngleFraction=fract(fAngle/(3.14*2.));\n\n    highp float fSegment=floor(fAngleFraction*fSteps+fSeed)+.5-fSeed;\n    highp float fParticleAngle=fSegment/fSteps*(3.14*2.);\n\n    highp float fSegmentPos=fSegment/fSteps;\n    highp float fRadius=fMinDist+Random(fSegmentPos+fSeed)*(fMaxDist-fMinDist);\n\n    highp float tunnelZ=vRayDir.z/length(vRayDir.xy/fRadius);\n\n    tunnelZ+=fZPos;\n\n    highp float fRepeat=fRepeatMin+Random(fSegmentPos+.1+fSeed)*(fRepeatMax-fRepeatMin);\n\n    highp float fParticleZ=(ceil(tunnelZ/fRepeat)-.5)*fRepeat-fZPos;\n\n    return vec3(sin(fParticleAngle)*fRadius,cos(fParticleAngle)*fRadius,fParticleZ);\n}\n\nhighp vec3 Starfield(const in highp vec3 vRayDir,const in highp float fZPos,const in highp float fSeed){\n    highp vec3 vParticlePos=GetParticlePos(vRayDir,fZPos,fSeed);\n    return GetParticleColour(vParticlePos,fParticleSize,vRayDir);\n}\n\nhighp float sharpen(highp float pix_coord){\n    highp float norm=(fract(pix_coord)-.5)*2.;\n    highp float norm2=norm*norm;\n    return floor(pix_coord)+norm*pow(norm2,sharpness)/2.+.5;\n}",
    "contentParticle": "uv = gl_FragCoord.xy/iResolution.xy;\n    highp vec2 vScreenPos=uv*2.-1.;\n    vScreenPos.x*=iResolution.x/iResolution.y;\n\n    highp vec3 vRayDir=normalize(vec3(vScreenPos,1.));\n\n    highp float fShade=0.;\n\n    highp float fZPos=5.+iTime;\n\n    fParticleLength=.00001;\n\n    highp float fSeed=0.;\n\n    highp vec3 vResult=mix(vec3(0.),vec3(0.),vRayDir.y*.5+.5);\n\n    for(highp int i=0;i<PASS_COUNT;i++){\n        vResult+=Starfield(vRayDir,fZPos,fSeed);\n        fSeed+=1.234;\n    }\n\n    particle =sqrt(vResult);"
  },
  "transitionSource": {
    "contentVariable": "",
    "contentFunction": "",
    "contentTransition": ""
  },
  "backgroundEffectId": 1,
  "thumbEffectId": 0
}
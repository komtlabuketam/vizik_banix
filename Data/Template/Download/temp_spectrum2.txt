{
  "audioUrl": "Music/Audio/Upbeat/indie-rock-far-away-15040.mp3",
  "audioFileName": "indie-rock-far-away-15040.mp3",
  "thumbUrl": "Thumb/Download/thumb_19.png",
  "thumbFileName": "thumb_19.png",
  "visualizerSource": {
    "contentVariable": "#define FREQ_STEP 0.001953125\n#define TWO_PI 6.283185",
    "contentFunction": "highp float getAvgVolume(highp float v, highp int steps){\n    highp float sum = 0.0;\n    highp float x = 0.0;\n    for (highp int i = 0; i < steps; i++){\n        x = fract(v + float(i) * FREQ_STEP);\n        sum += texture2D(iChannel0, vec2(pow(x, 2.1), 0.0)).r * pow(x, 0.08);\n    }\n    return sum /= float(steps);\n}",
    "contentVisualizer": "highp vec2 res = iResolution.xy;\n    uv = (2.0 * gl_FragCoord.xy - res) * 0.6 / min(res.x, res.y);\n    uv.x = abs(uv.x);\n    uv.y *= -1.0;\n    highp float ps = 1.0 / min(res.x, res.y);\n    highp float avgVolume = getAvgVolume(0.3, 1);\n    //Volume pulse\n    uv *= 1.0 - smoothstep(0.3, 1.1, avgVolume) * 0.7;\n    //Polar coordinates, x - length, y - frequency\n    highp vec2 polarUV = vec2(length(uv), atan(uv.y, uv.x) / TWO_PI);\n    polarUV.y = fract((polarUV.y + 0.2) * 0.8);\n    highp float volume = getAvgVolume(polarUV.y, 20);\n    volume = pow(smoothstep(0.0, 0.9, volume), 4.0 / (avgVolume)) * 0.4; //Adjusting freq volume\n    highp float distToFreq = (volume - polarUV.x + 0.2);\n    highp float distToFreq2 = (volume - polarUV.x + 0.15);\n    //line\n//    visualizer += vec3(0.0, 0.0, 0.0)* smoothstep(1.0 - ps * 1.5, 1.0, 1.0 - abs(distToFreq))* smoothstep(-1.0, 1.0, avgVolume);\n//    visualizer += vec3(0.0, 0.90, 0.2)* smoothstep(1.0 - ps * 2.5, 1.0, 1.0 - abs(distToFreq2))* smoothstep(-1.0, 1.0, avgVolume);\n    //a la blured line\n    visualizer += vec3(0.102, 1.0, 0.059)* smoothstep(1.0 - 0.008 * pow(avgVolume * 3.0 + 1.0, 2.0), 1.0, 1.0 - abs(distToFreq));\n//    visualizer += vec3(0.102, 1.0, 0.059)* smoothstep(1.0 - 0.018 * pow(avgVolume * 3.0 + 1.0, 2.0), 1.0, 1.0 - abs(distToFreq));\n    //flash\n    visualizer += vec3(1.0, 1.0, 1.0)* pow(avgVolume, 8.0)* (1.0 - polarUV.x);\n    //Center fill\n    visualizer += vec3(0.102, 1.0, 0.059)* smoothstep(0.0, 0.01, distToFreq);\n    //    visualizer += vec3(0.15, 0.15, 0.11)* smoothstep(0.0, 0.16, distToFreq);\n    //Center circles\n    visualizer += vec3(0.102, 1.0, 0.059)* smoothstep(0.1, 0.3, distToFreq)* smoothstep(0.1, 0.8, pow(avgVolume, 2.0));"
  },
  "particleSource": {
    "contentVariable": "#define PASS_COUNT 1\n\nmediump float fBrightness = 2.5;\nmediump float fSteps = 121.0;\n\nmediump float fParticleSize = 0.015;\nmediump float fParticleLength = 0.5 / 60.0;\nmediump float fMinDist = 0.8;\nmediump float fMaxDist = 5.0;\n\nmediump float fRepeatMin = 1.0;\nmediump float fRepeatMax = 2.0;\nmediump float fDepthFade = 0.8;",
    "contentFunction": "mediump float Random(mediump float x){\n    return fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nmediump vec3 GetParticleColour( const in mediump vec3 vParticlePos, const in mediump float fParticleSize, const in mediump vec3 vRayDir ){\n    mediump vec2 vNormDir = normalize(vRayDir.xy);\n    mediump float d1 = dot(vParticlePos.xy, vNormDir.xy) / length(vRayDir.xy);\n    mediump vec3 vClosest2d = vRayDir * d1;\n\n    mediump vec3 vClampedPos = vParticlePos;\n\n    vClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\n    mediump float d = dot(vClampedPos, vRayDir);\n\n    mediump vec3 vClosestPos = vRayDir * d;\n\n    mediump vec3 vDeltaPos = vClampedPos - vClosestPos;\n\n    mediump float fClosestDist = length(vDeltaPos) / fParticleSize;\n\n    mediump float fShade = \tclamp(1.0 - fClosestDist, 0.0, 1.0);\n\n    fShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\n    return vec3(fShade);\n}\n\nmediump vec3 GetParticlePos( const in mediump vec3 vRayDir, const in mediump float fZPos, const in mediump float fSeed ){\n    mediump float fAngle = atan(vRayDir.x, vRayDir.y);\n    mediump float fAngleFraction = fract(fAngle / (3.14 * 2.0));\n\n    mediump float fSegment = floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n    mediump float fParticleAngle = fSegment / fSteps * (3.14 * 2.0);\n\n    mediump float fSegmentPos = fSegment / fSteps;\n    mediump float fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\n    mediump float tunnelZ = vRayDir.z / length(vRayDir.xy / fRadius);\n\n    tunnelZ += fZPos;\n\n    mediump float fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\n    mediump float fParticleZ = (ceil(tunnelZ / fRepeat) - 0.5) * fRepeat - fZPos;\n\n    return vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nmediump vec3 Starfield( const in mediump vec3 vRayDir, const in mediump float fZPos, const in mediump float fSeed ){\n    mediump vec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\n    return GetParticleColour(vParticlePos, fParticleSize, vRayDir);\n}\n\nmediump vec3 RotateX( const in mediump vec3 vPos, const in mediump float fAngle ){\n    mediump float s = sin(fAngle);\n    mediump float c = cos(fAngle);\n\n    mediump vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n\n    return vResult;\n}\n\nmediump vec3 RotateY( const in mediump vec3 vPos, const in mediump float fAngle ){\n    mediump float s = sin(fAngle);\n    mediump float c = cos(fAngle);\n\n    mediump vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\n    return vResult;\n}\n\nmediump vec3 RotateZ( const in mediump vec3 vPos, const in mediump float fAngle ){\n    mediump float s = sin(fAngle);\n    mediump float c = cos(fAngle);\n\n    mediump vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n\n    return vResult;\n}",
    "contentParticle": "uv = gl_FragCoord.xy / iResolution.xy;\n    mediump vec2 vScreenPos = uv * 2.0 - 1.0;\n    vScreenPos.x *= iResolution.x / iResolution.y;\n    mediump vec3 vRayDir = normalize(vec3(vScreenPos, 1.0));\n    mediump vec3 vEuler = vec3(0.5 + sin(iTime * 0.2) * 0.125, 0.5 + sin(iTime * 0.1) * 0.125, iTime * 0.1 + sin(iTime * 0.3) * 0.5);\n    vRayDir = RotateX(vRayDir, vEuler.x);\n    vRayDir = RotateY(vRayDir, vEuler.y);\n    vRayDir = RotateZ(vRayDir, vEuler.z);\n    mediump float fShade = 0.0;\n    mediump float a = 0.2;\n    mediump float b = 10.0;\n    mediump float c = 1.0;\n    mediump float fZPos = 5.0 + iTime * c + sin(iTime * a) * b;\n    mediump  float fSpeed = c + a * b * cos(a * iTime);\n    fParticleLength = 0.25 * fSpeed / 60.0;\n    mediump float fSeed = 0.0;\n    mediump vec3 vResult = mix(vec3(0.005, 0.0, 0.01), vec3(0.01, 0.005, 0.0), vRayDir.y * 0.5 + 0.5);\n    for(mediump int i=0; i<PASS_COUNT; i++){\n        vResult += Starfield(vRayDir, fZPos, fSeed);\n        fSeed += 1.234;\n    }\n\n    particle = sqrt(vResult);"
  },
  "transitionSource": {
    "contentVariable": "",
    "contentFunction": "mediump vec2 mirror(mediump vec2 v) {\n    mediump vec2 m = mod(v, 2.0);\n    return mix(m, 2.0 - m, step(1.0, m));\n}\n\nmediump float tri(mediump float p) {\n    return mix(p, 1.0 - p, step(0.5, p))*2.0;\n}",
    "contentTransition": "mediump vec2 vuv1 = uv;\n        mediump float p = pow(min(cos(3.1415926 * (mod(translatePercent,2.)-1.) / 2.), 1. - abs(mod(translatePercent,2.) - 1.)  ), 1. );\n\n        mediump float delayValue = p*7. - uv.y*2. + uv.x - 2.0 ;\n        delayValue = clamp(delayValue,0.,1.);\n\n        mediump vec2 acc = vec2(0.5,2.);\n\n        mediump vec2 translateValue = p + delayValue * acc;\n        mediump vec2 translateValue1 = vec2(-0.5,1.)* translateValue;\n        mediump vec2 translateValue2 = vec2(-0.5,1.) * (translateValue - 1.0 - acc);\n\n        mediump vec2 w = sin( sin(translatePercent)*vec2(0,0.3) + uv*vec2(0,4.)) * vec2(0, 0.5);\n        mediump vec2 xy = w*(tri(p)*0.5 + tri(delayValue)*0.5);\n\n        mediump vec2 uv1 = vuv1 + translateValue1 + xy;\n        mediump vec2 uv2 = vuv1 + translateValue2 + xy;\n        mediump vec4 t0 = texture2D(iChannel1,mirror(uv1));\n        mediump vec4 t1 = texture2D(iChannel3,mirror(uv2));\n        background = mix(t0, t1, delayValue).rgb;"
  },
  "backgroundEffectId": 1,
  "thumbEffectId":1
}